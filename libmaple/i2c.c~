/* *****************************************************************************
 * The MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 *  Created: Thu Mar 18 13:54:17
 *  Copyright (c) 2010 Bryan Newbold. All rights reserved.
 *
 * ****************************************************************************/

// See also ../../notes/i2c

/**
 *  @file i2c.c
 *
 *  @brief i2c control routines
 */

#include "libmaple.h"
#include "i2c.h"
#include "gpio.h"
#include "nvic.h"
#include "rcc.h"

#define IS_VALID_I2C_NUM(NUM) (NUM == 1) || (NUM == 2)

#define I2C_MAX_FREQ 400000

typedef struct i2c_state {
    uint32 *data;
    uint32 length;
    uint32 offset;
} i2c_state;

static i2c_state i2c1_state;
static i2c_state i2c2_state;

void i2c_init(uint32 i2c_num, uint32 freq) {
    ASSERT(IS_VALID_I2C_NUM(i2c_num));

    i2c_port *port;
    freq = 100000;  // TODO: this
    
    switch (i2c_num) {
        case I2C_PORT1:
            port = (i2c_port*)I2C1_BASE;
            port->CR1 |= I2C_CR1_SWRST;  // reset the peripheral
            port->CR1 &= ~I2C_CR1_SWRST; // re-enable
            port->CR1 &= (~ I2C_CR1_PE); // disable the hardware to configure

            // Configure I2C pins: SCL and SDA 
            // On the maple, I2C1 SCL is header pin D5 and I2C1 SDA is D9
            gpio_set_mode(GPIOB_BASE, 6, GPIO_MODE_AF_OUTPUT_OD);
            gpio_set_mode(GPIOB_BASE, 7, GPIO_MODE_AF_OUTPUT_OD);

            // setup peripheral input clock
            rcc_enable_clk_gpiob(); /* Enable GPIOB clock */
            rcc_enable_clk_i2c1(); /* Enable I2C1 clock */
            rcc_reset_i2c1();

            // configure interupts; maybe this should be at the end?
            nvic_enable_interrupt(NVIC_INT_I2C1_EV);
            nvic_enable_interrupt(NVIC_INT_I2C1_ER);
            break;
        case I2C_PORT2: 
            // not yet
        default:   // should never get here
            ASSERT(0);
    }

    port->CR2 |= (port->CR2 & 0xFFC0) | 36; // set clock to 36MHz

    // configure clock control registers
    // Set speed value for standard mode; this is equal to the number of peripheral clock cycles
    // required for a full T_high or T_low (half a clock period):
    // CCR_VAL = periph_clk / (2*i2c_speed)
    port->CCR = 36000000/(2*freq);
    //port->CCR = 0xB4; // 100kHz w/ 36MHz clock rate
    if(freq <= 100000) {
        port->CCR &= (~ I2C_CCR_FS); // standard mode
    } else {
        port->CCR |= I2C_CCR_FS; // fast mode
        // TODO: configure the other register here?
    }
    
    // configure rise time register
    // this is equal the number of cycles to meet a given rise time
    // TRISE = (periph_clk * rise_time) + 1
    if(freq <= 100000) {
        port->TRISE = (36000000 * (1/1000000)) + 1; // 1 microsecond for Standard
        //port->TRISE = 37; // for 100kHz standard w/ 36MHz clock rate
    } else {
        port->TRISE = (36000000 * (1/4000000)) + 1; // TODO: guessing .25 microseconds for Fast mode?
    }
    // configure I2C_CR1, I2C_CR2 to enable the peripheral
    port->CR1 &= (~ (I2C_CR1_PEC | I2C_CR1_SMBUS | I2C_CR1_SMBTYPE | I2C_CR1_NOSTRETCH )); 
    // enable all interrupts on the peripheral side
    port->CR2 |= (I2C_CR2_ITBUFEN | I2C_CR2_ITEVTEN | I2C_CR2_ITBUFEN);

    // set ACK flag low: won't be a slave until addr is set
    port->CR1 &= (~ I2C_CR1_ACK);
    
    // Re-enable port after configuration
    port->CR1 |= I2C_CR1_PE; 
}

// for testing
void i2c_start() {
    i2c_port *port;
    port = (i2c_port*)I2C1_BASE;
    port->CR1 |= I2C_CR1_START; 
}

// for testing
void i2c_send1(uint32 addr) {
    i2c_port *port;
    port = (i2c_port*)I2C1_BASE;
    
    port->CR1 |= I2C_CR1_START; 

    while (! (port->SR1 & I2C_SR1_SB)) { 
        asm volatile("nop");
    }
    port->DR = (addr & 0x7F) << 1;
    //port->DR = 0x8; // ADDR of slave device: "4" plus LSB is low for transmit
    while (! ((port->SR1 & I2C_SR1_ADDR) && (port->SR2 & I2C_SR2_TRA))) { // addr accepted? transmitting?
        asm volatile("nop");
    }
    port->DR = 0x5; // set data
    port->SR1 &= ~ I2C_SR1_ADDR; // clear addr
    port->CR1 |= I2C_CR1_STOP; // only sending the one byte; this could be inserted above the DR write?

    while (port->SR1 & I2C_SR1_STOPF) { 
        asm volatile("nop");
    }
}

// for testing
uint32 i2c_read1(uint32 addr) {
    i2c_port *port;
    port = (i2c_port*)I2C1_BASE;
    uint32 ret;
    uint8 oldack = port->CR1 & I2C_CR1_ACK;

    // set ACK flag low b/c we're going to NACK after the first byte
    port->CR1 &= (~ I2C_CR1_ACK);

    // start
    port->CR1 |= I2C_CR1_START; 

    while (! (port->SR1 & I2C_SR1_SB)) { 
        asm volatile("nop");
    }
    port->DR = ((addr & 0x7F) << 1) & 0x1;
    port->DR = 0x9; // ADDR of slave device: "4" plus LSB is low for transmit
    
    // addr accepted? transmitting?
    while (! ((port->SR1 & I2C_SR1_ADDR) && (! (port->SR2 & I2C_SR2_TRA)))) { 
        asm volatile("nop");
    }
    port->SR1 &= (~ I2C_SR1_ADDR); // clear it
    port->CR1 |= I2C_CR1_STOP;     // only reading the one byte

    // stuff to read?
    while (! (port->SR1 & I2C_SR1_BTF)) { 
        asm volatile("nop");
    }
    ret = port->DR;                 // get data
    port->SR1 &= ~ I2C_SR1_BTF;     // clear addr

    while (port->SR1 & I2C_SR1_STOPF) { 
        asm volatile("nop");
    }
    
    // ok we're done; return to previous state
    if(oldack) {
        port->CR1 |= I2C_CR1_ACK;
    } else {
        port->CR1 &= (~ I2C_CR1_ACK);
    }
    return ret;
}

// completely tears down the periph?
void i2c_disable(uint32 i2c_num) {
    ASSERT(IS_VALID_I2C_NUM(i2c_num));
    i2c_port *port;

    switch (i2c_num) {
    case I2C_PORT1:
        port = (i2c_port*)I2C1_BASE;
        break;
    case I2C_PORT2:
        port = (i2c_port*)I2C2_BASE;
        break;
    default:
        ASSERT(0); // shouldn't ever get here
    }

    port->CR1 &= (~ I2C_CR1_PE); // unset enable pin
    port->CR1 |= I2C_CR1_SWRST;  // reset the peripheral
    port->CR1 &= ~I2C_CR1_SWRST; // re-enable
    port->CR1 &= (~ I2C_CR1_PE); // unset enable pin again after reset
}

uint32 i2c_master_read(uint32 i2c_num, uint32 addr, uint32* data, uint32 len) {
    return i2c_master_writeread(i2c_num, addr, 0, 0, (uint32*)data, len);
}

uint32 i2c_master_write(uint32 i2c_num, uint32 addr, uint32* data, uint32 len) {
    return i2c_master_writeread(i2c_num, addr, (uint32*)data, len, 0, 0);
}

// duh duh doing it yeah
// addr is the target, data is a pointer to an array to write into, leng is how much
uint32 i2c_master_writeread(uint32 i2c_num, uint32 addr, uint32* wdata, uint32 wlen,
                            uint32 *rdata, uint32 rlen) {

    ASSERT(IS_VALID_I2C_NUM(i2c_num));
    i2c_port *port;
    uint32 startmillis = millis();

    switch (i2c_num) {
    case I2C_PORT1:
        port = (i2c_port*)I2C1_BASE;
        break;
    case I2C_PORT2:
        port = (i2c_port*)I2C2_BASE;
        break;
    default:
        ASSERT(0); // shouldn't ever get here
    }

    while(0) { // TODO: is busy?
        asm volatile("nop");
        if(millis() - startmillis > I2C_TIMEOUT) {
            i2c_disable(i2c_num);
            return 0;
        }
    }
    // TODO: umkay do stuff
}

// sets up the periph as a slave device
// addr is expected to be 7bits
void i2c_slave_set_addr(uint32 i2c_num, uint32 addr) {
    ASSERT(IS_VALID_I2C_NUM(i2c_num));
    i2c_port *port;

    switch (i2c_num) {
    case I2C_PORT1:
        port = (i2c_port*)I2C1_BASE;
        break;
    case I2C_PORT2:
        port = (i2c_port*)I2C2_BASE;
        break;
    default:
        ASSERT(0); // shouldn't ever get here
    }

    port->OAR1 &= (~ I2C_OAR1_ADDMODE); // 7-bit mode
    port->OAR1 = (addr & 0x7F) << 1;

    // set ACK flag high to start ACK-ing
    port->CR1 |= I2C_CR1_ACK;
}

void i2c_slave_set_begin_callback(uint32 i2c_num, void (*function)(void)) {
    //TODO
    ASSERT(IS_VALID_I2C_NUM(i2c_num));
    return;
}

void i2c_slave_set_rx_callback(uint32 i2c_num, void (*function)(uint8*)) {
    //TODO
    ASSERT(IS_VALID_I2C_NUM(i2c_num));
    return;
}

void i2c_slave_set_tx_callback(uint32 i2c_num, uint8 (*function)(void)) {
    // TODO
    ASSERT(IS_VALID_I2C_NUM(i2c_num));
    return;
}

void i2c_slave_set_end_callback(uint32 i2c_num, void (*function)(void)) {
    //TODO
    ASSERT(IS_VALID_I2C_NUM(i2c_num));
    return;
}

// this just implements a single send for now
void I2C1_EV_IRQHandler(void) {
    i2c_port *port;
    port = (i2c_port*)I2C1_BASE;

    uint16 SR1 = port->SR1;
    uint16 SR2 = port->SR2;

    // are we master or slave?
    if(port->SR2 & I2C_SR2_MSL) { // we're master
        
        if(SR1 & I2C_SR1_SB) {
            // - when START actually happens, SB is set and interrupt happens; hardware
            //   waits until address is written to DR
            port->DR = 0x8; // ADDR of slave device; LSB is read/write mode
        } else if((SR1 & I2C_SR1_ADDR) && (SR2 & I2C_SR2_TRA)) {
            // - address shifts out and an interrupt is thrown with ADDR high; if LSB of
            //   address was low, in transmitter mode. TRA reflects this
            // - software writes to the first byte to DR and clears ADDR
            port->DR = 0x5;
            port->SR1 &= ~ I2C_SR1_ADDR;
            port->CR1 |= I2C_CR1_STOP;  // only 1 byte so stop here
        } else if (port->SR1 & I2C_SR1_STOPF) {
            // nothing, hardware takes care of us
        }
    } else { // we're slave

    }
    return;
}

void I2C1_ER_IRQHandler(void) {
    ASSERT(0);  // for testing/debugging
    return;
}
void I2C2_EV_IRQHandler(void) {
    ASSERT(0);  // for testing/debugging
    return;
}
void I2C2_ER_IRQHandler(void) {
    ASSERT(0);  // for testing/debugging
    return;
}


